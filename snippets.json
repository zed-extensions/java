{
  "package": {
    "prefix": "jpkg",
    "body": ["package ${1:com.example};", "", "$0"],
    "description": "Package declaration."
  },
  "import": {
    "prefix": "jimp",
    "body": ["import ${1:java.util.*};", "$0"],
    "description": "Import statement."
  },
  "static import": {
    "prefix": "jimps",
    "body": ["import static ${1:org.junit.jupiter.api.Assertions}.*;", "$0"],
    "description": "Static import statement."
  },

  "class": {
    "prefix": "jclass",
    "body": ["public class ${1:ClassName} {", "  $0", "}", ""],
    "description": "Public class skeleton."
  },
  "final class": {
    "prefix": "jfclass",
    "body": ["public final class ${1:ClassName} {", "  $0", "}", ""],
    "description": "Final class skeleton."
  },
  "abstract class": {
    "prefix": "jabs",
    "body": ["public abstract class ${1:AbstractName} {", "  $0", "}", ""],
    "description": "Abstract class skeleton."
  },
  "interface": {
    "prefix": "jint",
    "body": ["public interface ${1:MyInterface} {", "  $0", "}", ""],
    "description": "Interface skeleton."
  },
  "enum": {
    "prefix": "jenum",
    "body": ["public enum ${1:MyEnum} {", "  ${2:VALUE};", "  $0", "}", ""],
    "description": "Enum skeleton."
  },
  "record (Java 16+)": {
    "prefix": "jrec",
    "body": ["public record ${1:Name}(${2:Type field}) {", "  $0", "}", ""],
    "description": "Record skeleton."
  },
  "sealed interface (Java 17+)": {
    "prefix": "jsealedint",
    "body": [
      "public sealed interface ${1:Shape} permits ${2:Circle}, ${3:Square} {",
      "  $0",
      "}",
      ""
    ],
    "description": "Sealed interface skeleton."
  },
  "sealed class (Java 17+)": {
    "prefix": "jsealedclass",
    "body": [
      "public sealed class ${1:Base} permits ${2:ChildA}, ${3:ChildB} {",
      "  $0",
      "}",
      ""
    ],
    "description": "Sealed class skeleton."
  },

  "class + main": {
    "prefix": "jmain",
    "body": [
      "public class ${1:Main} {",
      "  public static void main(String[] args) {",
      "    $0",
      "  }",
      "}",
      ""
    ],
    "description": "Class with main method."
  },
  "private field": {
    "prefix": "jpf",
    "body": ["private ${1:Type} ${2:name};", "$0"],
    "description": "Private field."
  },
  "private final field": {
    "prefix": "jpff",
    "body": ["private final ${1:Type} ${2:name};", "$0"],
    "description": "Private final field."
  },
  "public static final constant": {
    "prefix": "jconst",
    "body": ["public static final ${1:Type} ${2:NAME} = ${3:value};", "$0"],
    "description": "Constant declaration."
  },

  "constructor": {
    "prefix": "jctor",
    "body": [
      "public ${1:ClassName}(${2:Type ${3:arg}}) {",
      "  this.${4:field} = ${3:arg};",
      "  $0",
      "}",
      ""
    ],
    "description": "Constructor template."
  },
  "no-args constructor": {
    "prefix": "jctor0",
    "body": ["public ${1:ClassName}() {", "  $0", "}", ""],
    "description": "No-args constructor."
  },

  "getter": {
    "prefix": "jget",
    "body": [
      "public ${1:Type} get${2:Name}() {",
      "  return ${3:field};",
      "}",
      ""
    ],
    "description": "Getter method."
  },
  "setter": {
    "prefix": "jset",
    "body": [
      "public void set${1:Name}(${2:Type} ${3:value}) {",
      "  this.${4:field} = ${3:value};",
      "}",
      ""
    ],
    "description": "Setter method."
  },
  "method (public)": {
    "prefix": "jpubm",
    "body": [
      "public ${1:void} ${2:methodName}(${3:Type arg}) {",
      "  $0",
      "}",
      ""
    ],
    "description": "Public method template."
  },
  "method (private)": {
    "prefix": "jprim",
    "body": [
      "private ${1:void} ${2:methodName}(${3:Type arg}) {",
      "  $0",
      "}",
      ""
    ],
    "description": "Private method template."
  },
  "static method": {
    "prefix": "jstaticm",
    "body": [
      "public static ${1:void} ${2:methodName}(${3:Type arg}) {",
      "  $0",
      "}",
      ""
    ],
    "description": "Static method template."
  },
  "generic method": {
    "prefix": "jgenm",
    "body": [
      "public static <${1:T}> ${1:T} ${2:methodName}(${1:T} ${3:value}) {",
      "  return ${3:value};",
      "}",
      ""
    ],
    "description": "Generic method template."
  },

  "override method": {
    "prefix": "joverride",
    "body": [
      "@Override",
      "public ${1:void} ${2:methodName}(${3:Type arg}) {",
      "  $0",
      "}",
      ""
    ],
    "description": "@Override method template."
  },

  "equals/hashCode (Objects)": {
    "prefix": "jeqh",
    "body": [
      "@Override",
      "public boolean equals(Object o) {",
      "  if (this == o) return true;",
      "  if (o == null || getClass() != o.getClass()) return false;",
      "  ${1:ClassName} that = (${1:ClassName}) o;",
      "  return java.util.Objects.equals(${2:field}, that.${2:field});",
      "}",
      "",
      "@Override",
      "public int hashCode() {",
      "  return java.util.Objects.hash(${2:field});",
      "}",
      ""
    ],
    "description": "equals/hashCode using java.util.Objects."
  },
  "toString": {
    "prefix": "jts",
    "body": [
      "@Override",
      "public String toString() {",
      "  return \"${1:ClassName}{\" +",
      "      \"${2:field}=\" + ${2:field} +",
      "      '}';",
      "}",
      ""
    ],
    "description": "toString template."
  },
  "System.out.println": {
    "prefix": "sout",
    "body": ["System.out.println(${1:msg});", "$0"],
    "description": "Print to stdout."
  },
  "System.err.println": {
    "prefix": "serr",
    "body": ["System.err.println(${1:msg});", "$0"],
    "description": "Print to stderr."
  },

  "Javadoc (method)": {
    "prefix": "jdoc",
    "body": [
      "/**",
      " * ${1:Summary}",
      " *",
      " * @param ${2:param} ${3:description}",
      " * @return ${4:description}",
      " */",
      "$0"
    ],
    "description": "Javadoc template."
  },
  "TODO": {
    "prefix": "todo",
    "body": ["// TODO(${1:you}): ${2:what}", "$0"],
    "description": "TODO comment."
  },

  "if": {
    "prefix": "jif",
    "body": ["if (${1:condition}) {", "  $0", "}"],
    "description": "If statement."
  },
  "if/else": {
    "prefix": "jife",
    "body": ["if (${1:condition}) {", "  ${2:// ...}", "} else {", "  $0", "}"],
    "description": "If/else statement."
  },
  "switch statement": {
    "prefix": "jswitch",
    "body": [
      "switch (${1:expr}) {",
      "  case ${2:VALUE}:",
      "    $0",
      "    break;",
      "  default:",
      "    break;",
      "}"
    ],
    "description": "Switch statement."
  },
  "switch expression (Java 14+)": {
    "prefix": "jswitchx",
    "body": [
      "${1:var} = switch (${2:expr}) {",
      "  case ${3:VALUE} -> ${4:result};",
      "  default -> ${5:result};",
      "};",
      "$0"
    ],
    "description": "Switch expression."
  },

  "for (index)": {
    "prefix": "jfor",
    "body": ["for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {", "  $0", "}"],
    "description": "Indexed for loop."
  },
  "foreach": {
    "prefix": "jforeach",
    "body": ["for (${1:Type} ${2:item} : ${3:items}) {", "  $0", "}"],
    "description": "Enhanced for loop."
  },
  "while": {
    "prefix": "jwhile",
    "body": ["while (${1:condition}) {", "  $0", "}"],
    "description": "While loop."
  },
  "do/while": {
    "prefix": "jdowhile",
    "body": ["do {", "  $0", "} while (${1:condition});"],
    "description": "Do/while loop."
  },

  "requireNonNull": {
    "prefix": "jnonn",
    "body": [
      "java.util.Objects.requireNonNull(${1:obj}, \"${2:message}\");",
      "$0"
    ],
    "description": "Objects.requireNonNull guard."
  },
  "null guard return": {
    "prefix": "jngret",
    "body": ["if (${1:obj} == null) {", "  return ${2:null};", "}", "$0"],
    "description": "Null guard with return."
  },
  "null guard throw": {
    "prefix": "jngthrow",
    "body": [
      "if (${1:obj} == null) {",
      "  throw new ${2:IllegalArgumentException}(\"${3:message}\");",
      "}",
      "$0"
    ],
    "description": "Null guard with throw."
  },

  "try/catch": {
    "prefix": "jtry",
    "body": [
      "try {",
      "  $0",
      "} catch (${1:Exception} e) {",
      "  ${2:e.printStackTrace();}",
      "}"
    ],
    "description": "try/catch block."
  },
  "try/catch/finally": {
    "prefix": "jtryf",
    "body": [
      "try {",
      "  $0",
      "} catch (${1:Exception} e) {",
      "  ${2:e.printStackTrace();}",
      "} finally {",
      "  ${3:// cleanup}",
      "}"
    ],
    "description": "try/catch/finally block."
  },
  "try-with-resources": {
    "prefix": "jtryr",
    "body": [
      "try (${1:var} ${2:resource} = ${3:initializer}) {",
      "  $0",
      "} catch (${4:Exception} e) {",
      "  ${5:e.printStackTrace();}",
      "}"
    ],
    "description": "Try-with-resources."
  },

  "custom exception": {
    "prefix": "jex",
    "body": [
      "public class ${1:MyException} extends RuntimeException {",
      "  public ${1:MyException}(String message) {",
      "    super(message);",
      "  }",
      "",
      "  public ${1:MyException}(String message, Throwable cause) {",
      "    super(message, cause);",
      "  }",
      "}",
      ""
    ],
    "description": "Custom RuntimeException."
  },
  "List declaration": {
    "prefix": "jlist",
    "body": [
      "java.util.List<${1:Type}> ${2:list} = new java.util.ArrayList<>();",
      "$0"
    ],
    "description": "New ArrayList."
  },
  "Set declaration": {
    "prefix": "jset",
    "body": [
      "java.util.Set<${1:Type}> ${2:set} = new java.util.HashSet<>();",
      "$0"
    ],
    "description": "New HashSet."
  },
  "Map declaration": {
    "prefix": "jmap",
    "body": [
      "java.util.Map<${1:K}, ${2:V}> ${3:map} = new java.util.HashMap<>();",
      "$0"
    ],
    "description": "New HashMap."
  },

  "Stream filter/map/toList": {
    "prefix": "jstream",
    "body": [
      "${1:list}.stream()",
      "  .filter(${2:x} -> ${3:predicate})",
      "  .map(${2:x} -> ${4:transform})",
      "  .toList();",
      "$0"
    ],
    "description": "Stream pipeline (Java 16+ toList)."
  },
  "Collectors.toList": {
    "prefix": "jcolist",
    "body": [
      "${1:stream}.collect(java.util.stream.Collectors.toList());",
      "$0"
    ],
    "description": "Collect stream to list."
  },
  "Collectors.toMap": {
    "prefix": "jcomap",
    "body": [
      "${1:stream}.collect(java.util.stream.Collectors.toMap(",
      "  ${2:x} -> ${3:key},",
      "  ${2:x} -> ${4:value}",
      "));",
      "$0"
    ],
    "description": "Collect stream to map."
  },
  "Comparator.comparing": {
    "prefix": "jcomp",
    "body": ["java.util.Comparator.comparing(${1:Type}::${2:getField})", "$0"],
    "description": "Comparator.comparing reference."
  },

  "Optional.ofNullable": {
    "prefix": "jopt",
    "body": [
      "java.util.Optional.ofNullable(${1:value})",
      "  .orElse(${2:defaultValue});",
      "$0"
    ],
    "description": "Optional.ofNullable(...).orElse(...)."
  },
  "Optional.orElseThrow": {
    "prefix": "joptx",
    "body": [
      "${1:optional}.orElseThrow(() -> new ${2:IllegalStateException}(\"${3:message}\"));",
      "$0"
    ],
    "description": "Optional.orElseThrow with custom exception."
  },

  "logger (SLF4J)": {
    "prefix": "jlog",
    "body": [
      "private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(${1:ClassName}.class);",
      "$0"
    ],
    "description": "SLF4J logger field."
  },
  "log.info": {
    "prefix": "jinfo",
    "body": ["log.info(\"${1:message}: {}\", ${2:value});", "$0"],
    "description": "log.info with placeholder."
  },
  "log.warn": {
    "prefix": "jwarn",
    "body": ["log.warn(\"${1:message}: {}\", ${2:value});", "$0"],
    "description": "log.warn with placeholder."
  },
  "log.error (with throwable)": {
    "prefix": "jerr",
    "body": ["log.error(\"${1:message}\", ${2:throwable});", "$0"],
    "description": "log.error with throwable."
  },
  "Java: Thread (lambda)": {
    "prefix": "jthread",
    "body": ["new Thread(() -> {", "  $0", "}).start();"],
    "description": "Start a Thread with lambda."
  },
  "Java: Runnable": {
    "prefix": "jrunnable",
    "body": ["Runnable ${1:task} = () -> {", "  $0", "};"],
    "description": "Runnable lambda."
  },
  "Java: Callable": {
    "prefix": "jcallable",
    "body": [
      "java.util.concurrent.Callable<${1:T}> ${2:task} = () -> {",
      "  return $0;",
      "};"
    ],
    "description": "Callable lambda."
  },
  "Java: ExecutorService (fixed pool)": {
    "prefix": "jexec",
    "body": [
      "java.util.concurrent.ExecutorService ${1:pool} = java.util.concurrent.Executors.newFixedThreadPool(${2:nThreads});",
      "try {",
      "  $0",
      "} finally {",
      "  ${1:pool}.shutdown();",
      "}"
    ],
    "description": "ExecutorService fixed thread pool."
  },
  "Java: CompletableFuture.supplyAsync": {
    "prefix": "jcf",
    "body": [
      "java.util.concurrent.CompletableFuture<${1:T}> ${2:cf} = java.util.concurrent.CompletableFuture.supplyAsync(() -> {",
      "  return $0;",
      "});"
    ],
    "description": "CompletableFuture.supplyAsync template."
  },
  "Java: synchronized block": {
    "prefix": "jsync",
    "body": ["synchronized (${1:lock}) {", "  $0", "}"],
    "description": "Synchronized block."
  },
  "Java: ReentrantLock": {
    "prefix": "jlock",
    "body": [
      "java.util.concurrent.locks.Lock ${1:lock} = new java.util.concurrent.locks.ReentrantLock();",
      "${1:lock}.lock();",
      "try {",
      "  $0",
      "} finally {",
      "  ${1:lock}.unlock();",
      "}"
    ],
    "description": "ReentrantLock with try/finally."
  },

  "Java: Path.of": {
    "prefix": "jpath",
    "body": [
      "java.nio.file.Path ${1:path} = java.nio.file.Path.of(${2:\"file.txt\"});",
      "$0"
    ],
    "description": "Create a Path."
  },
  "Java: Files.readString": {
    "prefix": "jreadstr",
    "body": [
      "String ${1:text} = java.nio.file.Files.readString(${2:path});",
      "$0"
    ],
    "description": "Read file contents as String."
  },
  "Java: Files.readAllLines": {
    "prefix": "jreadlines",
    "body": [
      "java.util.List<String> ${1:lines} = java.nio.file.Files.readAllLines(${2:path});",
      "$0"
    ],
    "description": "Read all lines into List<String>."
  },
  "Java: Files.writeString": {
    "prefix": "jwritestr",
    "body": ["java.nio.file.Files.writeString(${1:path}, ${2:text});", "$0"],
    "description": "Write String to file."
  }
}
